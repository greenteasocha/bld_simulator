# 概要
与えられたキューブの state における cp, co から、完成状態に持っていくまでの操作列を計算します。
操作は、コーナーの2点交換のみで行われます。ルービックキューブの現実の操作では完全なコーナーの2点交換はできませんが、いったん抽象化して無視します。


# 手続き

## cp[0]との二点交換
2点交換は、全て cp[0] と他のいずれかの交換になります。
例を示します。
cp: [1,2,3,0,4,5,6,7]
co についてはあとで考えます。

まず最初の開始点を cp[0]とします。
cp[0] = 1 なので、0 と 1 の交換になります。
具体的には cp[0],cp[1] = cp[1],cp[0] です

この操作をすると
cp:[2,1,3,0,4,5,6,7]
になります。
同様に、cp[0] = 2 なので、0 と 2 の交換になります。
具体的には cp[0],cp[2] = cp[2],cp[0] です

結果、
cp: [3,1,2,0,4,5,6,7]
cp[0] と交換された値は、その配列内でのインデックスと実際の値が同じになることに留意してください。
この操作を繰り返すことによって完成状態である cp: [0,1,2,3,4,5,6,7] との距離を一つずつ縮めます。

操作をもう一度繰り返すと
cp: [0,1,2,3,4,5,6,7] になります。
もし cp[0] = 0 になった場合、別ループ探索もしくは終了に遷移します。

## 別ループ探索
cp[0] = 0 の場合、cp[i] = i ではない最小の i を探索します。
例えば cp: [0,1,2,3,4,6,7,5] を考えます。
条件に合うのは cp[5] (その値は6) なので、i = 5 です。
cp[0] と cp[5] の交換を行います。

結果、[6,1,2,3,4,0,7,5] となります。
cp[0] = 0 ではなくなったので、cp[0]との二点交換 の手続きに戻ります。

## 終了条件
別ループ探索　で、cp[i] = i ではない最小の i が見つからない場合があります。
これを終了条件とし、処理全体を終了します。
この時、かならず cp: [0,1,2,3,4,5,6,7] となっていることに留意してください。 


# co を考慮した手続き
次に、co を考慮した2点交換を定義します。

cp のみを考慮した手続きと変わらないのは以下です。
- cp[0] からスタートする
- cp[0] = 0 となった場合、別ループ探索を行う

異なるのは以下です。
- cp[0] と cp[i] の二点交換が起こる時、co[0] と co[i] にも変化が起こる
    - 変化のロジックは cp と異なり単純な交換ではない
- 終了条件のための co 専用の判断が追加される
- cp の終了条件が満たされるが co の終了条件が満たされない場合、二点交換とは異なる操作 (twist) を行う。
- 操作列の出力には、swap と twist を push 可能

## co 二点交換時の cp の変化
co を管理するに伴い、出力する操作列を以下のように変更してください。
{
    index1
    index2
    orientation // 交換操作を行う前の co[0] を記録する   
}

cp[0] と cp[i]　が交換されるとき、同時に以下の操作を行います。対称性がないことに注意してください。
co[0], co[i] = mod3(orientation + co[i]), mod3(co[0] - orientation)


## co 専用の終了条件
**cpの終了条件が満たされる場合にのみ**、追加で全ての co について以下の判断ロジックを追加します。

co[i] = 0 の場合何もしない。
そうでない場合、CornerTwistOperation{co: co[i]} を操作列に push して co[i] = 0 にする (正確には、mod3(co[i] - 操作列にpushした値))













(note for me: 別ループ探索では co のルールが変わる)


U' F U2 D2 F' U B U F U D2 F' B' D2 F' U2 D2 B
[1, 0, 6, 2, 5, 4, 3, 7],
[2, 1, 0, 2, 2, 2, 2, 1],


Step 1: Swap: 0 ↔ 1 (ori: 2)
Step 2: Swap: 0 ↔ 2 (ori: 0)
Step 3: Swap: 0 ↔ 6 (ori: 0)
Step 4: Swap: 0 ↔ 3 (ori: 2)
Step 5: Swap: 0 ↔ 2 (ori: 1)
Step 6: Swap: 0 ↔ 4 (ori: 1)
Step 7: Swap: 0 ↔ 5 (ori: 0)
Step 8: Swap: 0 ↔ 4 (ori: 2)
Step 9: Twist (co: 2)
Step 10: Twist (co: 1)